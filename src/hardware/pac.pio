.program pac
.wrap_target
    set pins, 0
    wait 1 pin 0                ; Wait until zero crossing
    pull noblock                ; Pull from FIFO to OSR if available, else copy X to OSR, also turn off out pin
    mov x, osr                  ; Copy pulse_width to x
    mov y, osr                  ; Copy pulse_width to y
off_wait:
    jmp y--, off_wait           ; Wait for pulse_width clock cycles
    set pins, 1  [10]
.wrap

% c-sdk {
#include "hardware/clocks.h"
static inline void pac_pio_init(PIO pio, uint sm, uint offset, uint out_pin, uint zero_pin) {
    pio_gpio_init(pio, zero_pin);
    pio_gpio_init(pio, out_pin);
    gpio_pull_up(zero_pin);
    pio_sm_set_consecutive_pindirs(pio, sm, out_pin, 1, true);
    pio_sm_set_consecutive_pindirs(pio, sm, zero_pin, 1, false);
    pio_sm_config c = pac_program_get_default_config(offset);
    sm_config_set_clkdiv_int_frac(&c, 1000, 0);
    sm_config_set_in_pins(&c, zero_pin);
    sm_config_set_set_pins(&c, out_pin, 1);
    pio_sm_init(pio, sm, offset, &c);
}
static inline void pac_pio_set(PIO pio, uint sm, uint mains_freq, float val) {
    if (val > 0.99) {
        pio_sm_set_enabled(pio, sm, false);
        pio_sm_exec_wait_blocking(pio, sm, pio_encode_set(pio_pins, 1));
        return;
    }

    const float pio_freq = clock_get_hz(clk_sys) / 1000;
    const float cycles_in_half_wave = (pio_freq / mains_freq) / 2;
    const float on_cycles = val * cycles_in_half_wave + 4;

    if (on_cycles < 50 || val < 0.01) {
        pio_sm_set_enabled(pio, sm, false);
        pio_sm_exec_wait_blocking(pio, sm, pio_encode_set(pio_pins, 0));
        return;
    }

    pio_sm_set_enabled(pio, sm, true);
    pio_sm_put_blocking(pio, sm, cycles_in_half_wave - on_cycles);
}
%}
